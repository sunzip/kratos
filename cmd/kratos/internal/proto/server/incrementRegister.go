package server

import (
	"fmt"
	"log"
	"os"
	"path"
)

// https://www.jianshu.com/p/937d649039ec

// 增量处理
/*
	internal/prottocol/register.go
*/
var (
	lineAssignRegister             = "*PbServer-RegisterHTTP"
	clientAssign                   = "clientAssign"
	wireImport                     = "module-service"
	wireAutoWireAppPanicBuildParam = "wireAutoWireAppPanicBuildParam"
)

// 增加方法
//  在 // service grpc 之后添加?
//  1. PbServer 里添加
// 		grpc 服务里，不需要http
// 		TaskVideoPic pbInfo.TaskVideoPicHTTPServer
//  2. RegisterHTTP 里添加
// 		pbInfo.RegisterTaskVideoPicHTTPServer(srv, s.TaskVideoPic)
func incrementRegister(fileDir, fileName string, sourceFile *SourceFile, s *Service) bool {
	pbPkgName := "pbInfo"

	filePath := path.Join(fileDir, fileName)
	bs, err := os.ReadFile(filePath)
	if err != nil {
		panic(err)
	}

	// todo: infopb 需要参数告知

	// 2.
	registerService := fmt.Sprintf(`	//Code generated by %s. (语句已存在则不覆盖).
	%s.Register%[3]sHTTPServer(srv, s.%[3]s)`,
		s.ToolName, pbPkgName, s.Service)
	if !sourceFile.LineExist[lineAssignRegister] {
		if v, ok := sourceFile.Methods[lineAssignRegister]; ok {
			pre := bs[:v.EndPos-len(getEndOfLine()+"}")]
			next := append([]byte{}, bs[v.EndPos-len(getEndOfLine()+"}"):]...)
			bs = append(pre, []byte(registerService)...)
			bs = append(bs, next...)
		} else {
			fmt.Printf("没有找到func %s\n", lineAssignRegister)
		}
	} else {
		fmt.Printf("设置 Register service语句 %s 已存在\n", registerService)
	}
	// 1. type PbServer struct {
	if v, ok := sourceFile.Structs["PbServer"]; ok {
		fieldKey := fmt.Sprintf("%s-%s.%sHTTPServer", s.Service, pbPkgName, s.Service)
		if _, ok := v.Fields[fieldKey]; !ok {
			dataField := fmt.Sprintf(`	//Code generated by %s. (字段已存在则不覆盖).
	%s	%s.%sHTTPServer`, s.ToolName, s.Service, pbPkgName, s.Service)
			pre := bs[:v.LastFieldEndPos]
			next := append([]byte{}, bs[v.LastFieldEndPos:]...)
			bs = append(pre, []byte(dataField)...)
			bs = append(bs, next...)
		} else {
			fmt.Printf("PbServer field %s 已存在\n", fieldKey)
		}
	}

	// test
	filePath = path.Join(fileDir, fileName)
	if err := os.WriteFile(filePath, bs, 0o644); err != nil {
		log.Fatal(err)
	}

	return true
}
